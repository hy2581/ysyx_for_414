# ysyxSoC UART 实验任务说明

## 1. 项目背景
本项目是一个基于 RISC-V 架构的 SoC 设计与仿真实验（`ysyxSoC` + `npc`）。当前的实验重点是理解和实现 UART（通用异步收发传输器）的驱动逻辑，特别是处理 **FIFO 溢出** 与 **状态轮询**。

之前的实验中使用了“Hack”手段（修改 Verilog 强行打印、欺骗状态寄存器）来绕过硬件限制，导致无法观察到真实的“字符丢失”现象。现在的任务是**回归真实硬件行为**，并通过正确的软件驱动来解决问题。

## 2. 当前环境状态 (Checkpoint)

### 硬件 (Verilog)
*   **文件**: `ysyxSoC/perip/uart16550/rtl/uart_tfifo.v`
*   **状态**: 已修改。在数据写入 FIFO 的逻辑中添加了 `$write("%c", data_in);`。这是为了在仿真终端直接观察硬件是否成功接收了字符。
*   **注意**: 必须保留 `if (count < fifo_depth)` 检查，确保只有 FIFO 未满时才打印。

### 仿真器 (C++)
*   **文件**: `npc/csrc/dev/devices.cpp`
*   **状态**: 已修改。**注释掉了** `SERIAL_PORT` 写操作时的 `putchar`。
*   **目的**: 禁用仿真器的“上帝视角”打印，强制字符输出依赖于 Verilog 硬件逻辑。如果 FIFO 满导致硬件拒收，终端就不应显示字符。

### 软件 (AM/OS)
*   **文件**: `abstract-machine/am/src/platform/ysyxsoc/trm.c`
*   **状态**: `uart_init` 设置了极高的波特率（`DLL=1`）。`putch` 函数目前包含了一个简单的轮询循环。

### 运行结果
执行 `hello` 测试时，目前观察到的现象是 **字符丢失**（例如只输出 `Hello, world` 而不是完整的长字符串）。
*   **原因**: CPU 写入速度 > UART 发送速度 -> FIFO 满 -> 硬件丢弃数据 -> `$write` 不执行。
*   **判定**: 这是一个**正确**的中间状态，验证了硬件 FIFO 的物理限制。

## 3. 接下来的任务 (Mission)

你的目标是通过修改**软件代码**（驱动程序），在不修改硬件逻辑的前提下，实现字符的**完整输出**。

### 步骤 1: 理解与验证
1.  **编译仿真器**:
    ```bash
    make -C npc -f Makefile.soc
    ```
2.  **运行测试**:
    ```bash
    cd am-kernels/tests/cpu-tests
    make ARCH=riscv32e-ysyxsoc ALL=hello run
    ```
3.  **观察**: 确认终端输出是截断的（如 `Hello, world` 后面缺失），且测试显示 `PASS`（程序未卡死，但数据丢了）。

### 步骤 2: 修复驱动 (The Fix)
修改 `abstract-machine/am/src/platform/ysyxsoc/trm.c` 中的 `putch` 函数。

**当前可能有问题的逻辑**:
```c
void putch(char ch) {
  while ((*(volatile uint8_t *)(UART_BASE + UART_LSR) & 0x20) == 0); // 检查 THRE (Bit 5)
  *(volatile char *)(UART_BASE + UART_TX) = ch;
}
```
*   **任务**: 确认 `0x20` 是否正确对应 UART 16550 的 LSR 寄存器定义。
*   **调试**: 如果轮询逻辑正确，CPU 应该在 FIFO 满时**等待**，直到有空位。这样字符就不会丢，而是发送变慢。
*   **验证**: 修改后重新运行测试。如果成功，你应该看到完整的长字符串 `Hello, world! This is a very long string...`。

## 4. 关键文件路径索引
*   **UART 寄存器定义 (Verilog)**: `ysyxSoC/perip/uart16550/rtl/uart_regs.v`
*   **UART FIFO 逻辑 (Verilog)**: `ysyxSoC/perip/uart16550/rtl/uart_tfifo.v`
*   **仿真器 MMIO 拦截 (C++)**: `npc/csrc/dev/devices.cpp`
*   **软件驱动 (C)**: `abstract-machine/am/src/platform/ysyxsoc/trm.c`
*   **仿真器构建脚本**: `npc/Makefile.soc`

## 5. 注意事项
*   不要修改 `ysyxSoC/perip/uart16550/rtl/uart_top_apb.v` 中的 APB 时序修复（保留 `reg_we` 的修改），那是正确的。
*   如果你看到输出瞬间完成且不丢包，检查是否意外开启了 `devices.cpp` 的打印，或者 Verilog 里注释掉了 FIFO 满的判断。
